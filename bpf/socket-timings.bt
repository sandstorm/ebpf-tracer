#!/usr/local/bin/bpftrace

/*
 * Monitors round-trip times of request for processes with arg1 <= PID <= arg2
 * and prints a histogram of round-trip times in µs.
 * Histogram shows 100 µs buckets from 0 to 5k µs.
 */

BEGIN {
    printf("Monitoring round-trip times of request for processes with %d (arg1) <= PID <= %d (arg2)\n", $1, $2);
}

tracepoint:syscalls:sys_enter_sendto
/pid >= $1 && pid <= $2/
{
    if (@end[pid, tid, args->fd] == 0) {
        // first connection
        if (@start[pid, tid, args->fd] == 0) {
            @start[pid, tid, args->fd] = nsecs;
        }
    } else {
        // old connection finished, starting a new one
        $duration_us = (@end[pid, tid, args->fd] - @start[pid, tid, args->fd]) / 1000; // in ��s
        @us[pid, args->fd] = lhist($duration_us, 0, 5000, 100);

        // new start
        @start[pid, tid, args->fd] = nsecs;
        delete(@end[pid, tid, args->fd]);
    }
}

tracepoint:syscalls:sys_enter_recvfrom
/@start[pid, tid, args->fd]/
{
    @recvfromFd[pid, tid] = args->fd;
}

tracepoint:syscalls:sys_exit_recvfrom
// do not check for @recvfromFd[pid, tid] since the fd can be 0 when tracing ping (is this a bug?)
/pid >= $1 && pid <= $2/
{
    $fd = @recvfromFd[pid, tid];
    @end[pid, tid, $fd] = nsecs;
    delete(@recvfromFd[pid, tid]);
}

END {
    clear(@start);
    clear(@end);
    clear(@recvfromFd);
    printf("\n\nLatency Histogram from the start of the first request to the start of the first reply.\nIndexed by PID, FD in µs");
}
